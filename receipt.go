package main

import (
  "encoding/json"
  "io"
  "merkle-patrica-trie/common"
  "merkle-patrica-trie/rlp"
)

// Log represents a contract log event. These events are generated by the LOG opcode and
// stored/indexed by the node.
type Log struct {
  // Consensus fields:
  // address of the contract that generated the event
  Address common.Address `json:"address" gencodec:"required"`
  // list of topics provided by the contract.
  Topics []common.Hash `json:"topics" gencodec:"required"`
  // supplied by the contract, usually ABI-encoded
  Data []byte `json:"data" gencodec:"required"`
}

type Receipt struct {
  // Consensus fields: These fields are defined by the Yellow Paper
  Status            uint64 `json:"status"`
  CumulativeGasUsed uint64 `json:"cumulativeGasUsed" gencodec:"required"`
  Bloom             Bloom  `json:"logsBloom"         gencodec:"required"`
  Logs              []*Log `json:"logs"              gencodec:"required"`

  // Implementation fields: These fields are added by geth when processing a transaction.
  GasUsed           uint64         `json:"gasUsed" gencodec:"required"`
}

type ReceiptJSON struct {
  Status            *common.Uint64 `json:"status"`
  CumulativeGasUsed *common.Uint64 `json:"cumulativeGasUsed" gencodec:"required"`
  Bloom             *Bloom          `json:"logsBloom"         gencodec:"required"`
  Logs              []*Log          `json:"logs"              gencodec:"required"`
  GasUsed           *common.Uint64 `json:"gasUsed" gencodec:"required"`
}

// UnmarshalJSON unmarshals from JSON.
func (r *Receipt) UnmarshalJSON(input []byte) error {
  var dec ReceiptJSON
  if err := json.Unmarshal(input, &dec); err != nil {
    return err
  }
  r.Status = uint64(*dec.Status)
  r.CumulativeGasUsed = uint64(*dec.CumulativeGasUsed)
  r.Bloom = *dec.Bloom
  r.Logs = dec.Logs
  r.GasUsed = uint64(*dec.GasUsed)
  return nil
}

// UnmarshalJSON unmarshals from JSON.
func (l *Log) UnmarshalJSON(input []byte) error {
  type Log struct {
    Address     *common.Address `json:"address" gencodec:"required"`
    Topics      []common.Hash   `json:"topics" gencodec:"required"`
    Data        *common.Bytes  `json:"data" gencodec:"required"`
  }
  var dec Log
  if err := json.Unmarshal(input, &dec); err != nil {
    return err
  }
  l.Address = *dec.Address
  l.Topics = dec.Topics
  l.Data = *dec.Data
  return nil
}

const (
  // BloomByteLength represents the number of bytes used in a header log bloom.
  BloomByteLength = 256
)

// Bloom represents a 2048 bit bloom filter.
type Bloom [BloomByteLength]byte

// UnmarshalText b as a hex string with 0x prefix.
func (b *Bloom) UnmarshalText(input []byte) error {
  return common.UnmarshalFixedText("Bloom", input, b[:])
}

type rlpLog struct {
  Address common.Address
  Topics  []common.Hash
  Data    []byte
}

// EncodeRLP implements rlp.Encoder.
func (l *Log) EncodeRLP(w io.Writer) error {
  return rlp.Encode(w, rlpLog{Address: l.Address, Topics: l.Topics, Data: l.Data})
}

// receiptRLP is the consensus encoding of a receipt.
type receiptRLP struct {
  PostStateOrStatus []byte
  CumulativeGasUsed uint64
  Bloom             Bloom
  Logs              []*Log
}

var (
  receiptStatusFailedRLP     = []byte{}
  receiptStatusSuccessfulRLP = []byte{0x01}
)

const (
  // ReceiptStatusFailed is the status code of a transaction if execution failed.
  ReceiptStatusFailed = uint64(0)
)

func (r *Receipt) statusEncoding() []byte {
  if r.Status == ReceiptStatusFailed {
    return receiptStatusFailedRLP
  }
  return receiptStatusSuccessfulRLP
}

// EncodeRLP implements rlp.Encoder, and flattens the consensus fields of a receipt
// into an RLP stream. If no post state is present, byzantium fork is assumed.
func (r *Receipt) EncodeRLP(w io.Writer) error {
  return rlp.Encode(w, &receiptRLP{r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs})
}
